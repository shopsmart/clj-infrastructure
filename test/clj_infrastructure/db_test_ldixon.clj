(ns clj-infrastructure.db-test
  (:require [clojure.test :refer :all]
            [clojure.java.io :as io]
            [clojure.string :as str]
            [schema.core :as s :refer [=> =>*]]
            [clj-foundation.unit-test-common :as common]
            [clj-foundation.patterns :as p :refer [def-singleton-fn f]]
            [clj-foundation.millis :as millis]
            [clj-infrastructure.db :refer :all]
            [clojure.java.jdbc :as jdbc]
            [clj-time.core :as t]
            [clj-time.format :as tf])
  (:import [java.sql SQLException]))


(common/register-fixtures)


(def date-time-formatter  (tf/formatter "yyyyMMddHHmmss"))

(defn joda-date-time->str [& [joda-date-time formatter]]
  (tf/unparse (or formatter date-time-formatter) (or joda-date-time (t/now))))

(def date-time-str        (joda-date-time->str))

(defn base-tab-name->timestamped-tab-name [base-tab-name & [schema suffix]]
  (let [tab-name-pattern  (str base-tab-name "_%s")
        tab-name          (format tab-name-pattern (or suffix date-time-str))]
    (str (when schema (str schema ".")) tab-name)))

(def test-tab-schema      "integration_or_unit_test")
(def test-tab-base-name   "transaction_test")
(def fq-test-tab-name     (base-tab-name->timestamped-tab-name test-tab-base-name test-tab-schema))

(def redshift {:subprotocol "postgresql"
               :subname "//bradsdeals-dw.c6ys8mqalj7k.us-east-1.redshift.amazonaws.com:5439/bdw"
               :user "contentshift"
               :password "15C3B6E8109DCF09688E0DEB828B99A5AF5D61349FD125F1A5BF59F3443A19f3"
               :driver "org.postgresql.Driver"
               :tcpKeepAlive true
               :timeout-seconds 900})

(defn create-test-tab [& [fq-tab-name]]
  "Setup function to create test tables (called by fixture)"
  (dbconfig-override DB-SPEC redshift)
  (let [fq-tab-name (or fq-tab-name fq-test-tab-name)]
    (jdbc/with-db-connection [conn (dbconfig {} DB-SPEC)]
      (try
        (jdbc/execute!
          conn
          [(format "begin; drop table if exists %s; create table if not exists %s (id bigint, description varchar(1000)); commit;"
              fq-tab-name fq-tab-name)]
          {:transaction? true})
        (finally
          ; Ensure connection is closed in order to end any open transactions
          (when-let [jdbc-conn (:connection conn)]
           (when-not (.isClosed jdbc-conn) (.close jdbc-conn))))))))

(defn drop-test-tab [& [fq-tab-name]]
  "Setup function to drop test tables (called by fixture)"
  (dbconfig-override DB-SPEC redshift)
  (let [fq-tab-name (or fq-tab-name fq-test-tab-name)]
    (jdbc/with-db-connection [conn (dbconfig {} DB-SPEC)]
      (try
        (jdbc/execute!
          conn
          [(format "begin; drop table if exists %s; commit;" fq-tab-name)])
        (finally
          ; Ensure connection is closed in order to end any open transactions
          (when-let [jdbc-conn (:connection conn)]
           (when-not (.isClosed jdbc-conn) (.close jdbc-conn))))))))

(defn transaction-test-fixture [f]
  (create-test-tab)
  (f)
  (drop-test-tab))

; Use :once? will it override common/register-fixtures; if so how can we tack it onto other already configured :once fixtures?
(use-fixtures :once transaction-test-fixture)

(defquery find-animal "select ${select-columns} from test_data where ${where-column}=${where-val};"
  ABORT?-FN (constantly true))


(deftest database-access

  (testing "dbconfig mechanism"
    (dbconfig-override DB-SPEC
                       {:classname   "org.h2.Driver"
                        :subprotocol "h2:mem"
                        :subname     "demo;DB_CLOSE_DELAY=-1"
                        :user        "sa"
                        :password    ""})

    (is (= "sa" (dbconfig {} DB-SPEC :user)))

    (is (= :nothingness-and-emptiness (dbconfig {DB-SPEC :nothingness-and-emptiness} DB-SPEC))))

  (testing "Create table"
    (jdbc/db-do-commands
     (dbconfig {} DB-SPEC)
     "drop table if exists test_data;")

    (jdbc/db-do-commands
     (dbconfig {} DB-SPEC)
     (jdbc/create-table-ddl
      :test_data
      [[:id "INTEGER GENERATED BY DEFAULT AS IDENTITY(START WITH 100, INCREMENT BY 1) PRIMARY KEY"]
       [:name "VARCHAR(200)"]
       [:sound "VARCHAR(40)"]])))

  (testing "Insert rows"
    (jdbc/insert-multi!
     (dbconfig {} DB-SPEC)
     :test_data
     [{:name "Rabbit"
       :sound "Awwww! What's up, Doc?"}
      {:name "Pig"
       :sound "Oink"}
      {:name "Cow"
       :sound "Moo"}
      {:name "Dog"
       :sound "RRRRuuuuff"}]))


  (testing "simple prepare with configuration set using dbconfig-override."
    (jdbc/with-db-connection [conn (dbconfig {} DB-SPEC)]
      (dbconfig-override SQL-FN jdbc/query CONNECTION conn ABORT?-FN (constantly true))

      (let [make-sound (prepare "select sound from test_data where name='Pig';")
            result     (make-sound ::row-fn :sound)]

        (is (= "Oink" (first result)))
        (is (= 1 (count result))))))


  (testing "Prepare with both templates and bind variables; configuration set using parameters"
    (jdbc/with-db-connection [conn (dbconfig {} DB-SPEC)]

      (let [make-sound (prepare "select ${column} from test_data where name=${animal};"
                                SQL-FN jdbc/query CONNECTION conn ABORT?-FN (constantly true)
                                :column "sound" ::row-fn :sound)]

        (is (= "Moo"                    (first (make-sound :animal "Cow"))))
        (is (= "Awwww! What's up, Doc?" (first (make-sound :animal "Rabbit"))))
        (is (= "RRRRuuuuff"             (first (make-sound :animal "Dog")))))))


  (testing "defquery substitutes variables correctly"
    (jdbc/with-db-connection [conn (dbconfig {} DB-SPEC)]
      (is (= {:name "Cow" :sound "Moo"}
             (first (find-animal CONNECTION conn
                                 :select-columns "name,sound"
                                 :where-column "sound"
                                 :where-val "'Moo'")))))))



(defn create-test-table [conn]
  (jdbc/execute!
    conn
    [(format
        "begin;
        drop table if exists %s;
        create table if not exists %s (id bigint, description varchar(1000));
        commit;"
        fq-test-tab-name
        fq-test-tab-name)]
    {:transaction? true}))


(deftest redshift-transaction-behavior
  (testing "Validate (.setAutoCommit conn false) doesn't respect autocommit=false in db-do-commands."
      (dbconfig-override DB-SPEC redshift)
      (jdbc/with-db-connection [conn (dbconfig {} DB-SPEC)]

        (.setAutoCommit (:connection conn) false)

        (jdbc-succeeds
         (jdbc/db-do-commands
          conn
          [(format "drop table if exists %s;" fq-test-tab-name)
           (format "create table if not exists %s (id bigint, description varchar(100));" fq-test-tab-name)]))

        (jdbc-succeeds
         (jdbc/db-do-commands
          conn
          [(format "insert into %s values (1, 'Awwww! What''s up, Doc?'), (2, 'Moo')" fq-test-tab-name)
           (format "insert into %s values (3, 'Oink')" fq-test-tab-name)]))

        ;; If creating a separate connection/transaction shows that the above data is visible, thus autocommit
        ;; is not being respected.
        (jdbc/with-db-connection [conn2 (dbconfig {} DB-SPEC)]
          (is (not (= (:connection conn) (:connection conn2)))) ; Prove clojure.jdbc isn't reusing connections
          (is (.getAutoCommit (:connection conn2)))             ; ...and that conn2 has its own autoCommit property
          (is (not (empty? (jdbc/query conn2 [(format "select * from %s where id=3" fq-test-tab-name)])))))))


  (testing ":transaction? true behavior"
      (dbconfig-override DB-SPEC redshift)
      (jdbc/with-db-connection [conn (dbconfig {} DB-SPEC)]

        (.setAutoCommit (:connection conn) false)

        (jdbc-succeeds
         (create-test-table conn)

         (jdbc/execute!
          conn
          [(format
            "insert into %s values (1, 'Awwww! What''s up, Doc?'), (2, 'Moo');
             insert into %s values (3, 'Oink')"
            fq-test-tab-name fq-test-tab-name)]
          {:transaction? true}))

        (testing "Show that the above data has been fully committed in spite of autoCommit=false"
          (jdbc/with-db-connection [conn2 (dbconfig {} DB-SPEC)]
            (is (not (= (:connection conn) (:connection conn2)))) ; Prove clojure.jdbc isn't reusing connections
            (is (.getAutoCommit (:connection conn2)))             ; ...and that conn2 has its own autoCommit property
            (is (not (empty? (jdbc/query conn2 [(format "select * from %s where id=3" fq-test-tab-name)]))))))))


   (testing ":transaction? false behavior"
      (dbconfig-override DB-SPEC redshift)
      (jdbc/with-db-connection [conn (dbconfig {} DB-SPEC)]

        (.setAutoCommit (:connection conn) false)

        (jdbc-succeeds
         (create-test-table conn)

         (jdbc/execute!
          conn
          [(format
            "insert into %s values (1, 'Awwww! What''s up, Doc?'), (2, 'Moo');
             insert into %s values (3, 'Oink')"
            fq-test-tab-name fq-test-tab-name)]
          {:transaction? false})

         (.rollback (:connection conn)))

        (testing "Show that autocommit was respected (the explicit rollback removes the data from the insert)"
          (jdbc/with-db-connection [conn2 (dbconfig {} DB-SPEC)]
            (is (empty? (jdbc/query conn2 [(format "select * from %s where id=3" fq-test-tab-name)])))))))


  (testing "Only fully committed data is visible; rollback does not affect prior commits."
    (dbconfig-override DB-SPEC redshift)
    (jdbc/with-db-connection [conn (dbconfig {} DB-SPEC)]

      (.setAutoCommit (:connection conn) false)

      (jdbc-succeeds
       (create-test-table conn)

       (jdbc/execute!
        conn
        [(format
            "insert into %s values (1, 'Awwww! What''s up, Doc?'), (2, 'Moo');
             insert into %s values (3, 'Oink')"
            fq-test-tab-name fq-test-tab-name)]
        {:transaction? false})

       (.commit (:connection conn))

       (jdbc/execute!
        conn
        [(format
            "insert into %s values (4, 'moo'), (5, 'Keeeer');
             insert into %s values (6, 'woof')"
            fq-test-tab-name fq-test-tab-name)]
        {:transaction? false})

       (.rollback (:connection conn)))

      (testing "Show that commit was respected"
        (jdbc/with-db-connection [conn2 (dbconfig {} DB-SPEC)]
          (is (not (empty? (jdbc/query conn2 [(format "select * from %s where id<=3" fq-test-tab-name)]))))))

      (testing "Show that rollback was respected also"
        (jdbc/with-db-connection [conn2 (dbconfig {} DB-SPEC)]
          (is (empty? (jdbc/query conn2 [(format "select * from %s where id>3" fq-test-tab-name)])))))))


  (testing "autoCommit behavior"
    (dbconfig-override DB-SPEC redshift)
    (jdbc/with-db-connection [conn (dbconfig {} DB-SPEC)]
      (try

        (.setAutoCommit (:connection conn) true) ; It's the default, per docs, but just to be sure...

        (jdbc-succeeds
         (create-test-table conn)

         (testing "Explicit SQL transactions supercede :transaction? true"
           (jdbc/execute!
            conn
            [(format "begin;
              insert into %s values (1, 'Awwww! What''s up, Doc?');
              rollback;" fq-test-tab-name)]
            {:transaction? true})

           (jdbc/with-db-connection [conn2 (dbconfig {} DB-SPEC)]
             (is (empty? (jdbc/query conn2 [(format "select * from %s where id<=3" fq-test-tab-name)])))))


         (testing "Autocommit"
           (create-test-table conn)

           (jdbc/execute! conn ["begin;"] {:transaction? true})
           (jdbc/execute!
            conn [(format "insert into %s values (3, 'Oink');" fq-test-tab-name)] {:transaction? true})
           (jdbc/execute!
            conn [(format "insert into %s values (4, 'woof');" fq-test-tab-name)] {:transaction? true})
           (jdbc/execute! conn ["rollback;"] {:transaction? true})

           (jdbc/with-db-connection [conn2 (dbconfig {} DB-SPEC)]
             (is (not (empty? (jdbc/query conn2 [(format "select * from %s where id<=3" fq-test-tab-name)]))))))


         (testing "Rollback with autocommit=true"
           (create-test-table conn)

           (jdbc/execute!
            conn
            [(format "insert into %s values (5, 'moo');" fq-test-tab-name)]
            {:transaction? false})

           (testing "Show that commit was respected (d'oh; autocommit is on)"
             (jdbc/with-db-connection [conn2 (dbconfig {} DB-SPEC)]
               (is (not (empty? (jdbc/query conn2 [(format "select * from %s" fq-test-tab-name)]))))))

           (testing "Show that rollback is NOT respected (because autocommit is on)"

            ;; TODO: Review with Dave, should silently not do anything (not throw exception)
           (try
             (.rollback (:connection conn))
             (catch SQLException e
               (is (= "Cannot rollback when autoCommit is enabled." (.getMessage e)))))

             (jdbc/with-db-connection [conn2 (dbconfig {} DB-SPEC)]
               (is (not (empty? (jdbc/query conn2 [(format "select * from %s" fq-test-tab-name)]))))))))

        (catch Exception e
          (throw e))
        (finally
          ; Ensure connection is closed in order to end any open transactions
          (when-let [jdbc-conn (:connection conn)]
           (when-not (.isClosed jdbc-conn) (.close jdbc-conn)))))))


  ;; BEGIN: Autcommit = false + :transaction? false testing

  (testing "JDBC transaction mgmt mixed with SQL transaction mgmt (autocommit = false + {:transaction? false})"
    (dbconfig-override DB-SPEC redshift)

    (jdbc/with-db-connection [conn (dbconfig {} DB-SPEC)]
      (try

        (.setAutoCommit (:connection conn) false)

          (create-test-table conn)

          ; Sub test 1 setup

          (jdbc/execute! conn ["BEGIN;"] {:transaction? false})
          (jdbc/execute! conn
            [(format "insert into %s values (30, 'autocommit = false + :transaction? false; multiline SQL transaction markers w/ SQL rollback');" fq-test-tab-name)]
            {:transaction? false})
          (jdbc/execute! conn ["ROLLBACK;"] {:transaction? false})
          (.commit (:connection conn))
    
          ; Sub test 2 setup

          (jdbc/execute! conn ["BEGIN;"] {:transaction? false})
          (jdbc/execute! conn
            [(format "insert into %s values (31, 'autocommit = false + :transaction? false; multiline SQL transaction markers w/ SQL commit');" fq-test-tab-name)]
            {:transaction? false})
          (jdbc/execute! conn ["COMMIT;"] {:transaction? false})
          (.rollback (:connection conn))

          ; Sub test 3 setup

          (jdbc/execute! conn ["BEGIN;"] {:transaction? false})
          (jdbc/execute! conn
            [(format "insert into %s values (32, 'autocommit = false + :transaction? false; multiline SQL transaction markers w/JDBC commit');" fq-test-tab-name)]
            {:transaction? false})
          (.commit (:connection conn))

          ; Sub test 4 setup

          (jdbc/execute! conn ["BEGIN;"] {:transaction? false})
          (jdbc/execute! conn
            [(format "insert into %s values (33, 'autocommit = false + :transaction? false; multiline SQL transaction markers w/JDBC rollback (implicit)');" fq-test-tab-name)]
            {:transaction? false})

        (catch Exception e
          (throw e))
        (finally
          ; Ensure connection is closed in order to end any open transactions
          (when-let [jdbc-conn (:connection conn)]
           (when-not (.isClosed jdbc-conn) (.close jdbc-conn)))))))
        
    (jdbc/with-db-connection [conn-read (dbconfig {} DB-SPEC)]
      (try

        (testing "Show that transaction (autocommit = false + {:transaction? false}) using SQL trans markers (BEGIN, END, etc.) spanning statements are respected (v1)"
          (is (empty? (jdbc/query conn-read [(format "select * from %s where id = 30" fq-test-tab-name)]))))

        (testing "Show that transaction (autocommit = false + {:transaction? false}) using SQL trans markers (BEGIN, END, etc.) spanning statements are respected (v2)"
          (is (not (empty? (jdbc/query conn-read [(format "select * from %s where id = 31" fq-test-tab-name)])))))

        (testing "Show that transaction (autocommit = false + {:transaction? false}) using SQL trans marker (BEGIN) spanning statements is properly committed w/JDBC commit"
          (is (not (empty? (jdbc/query conn-read [(format "select * from %s where id = 32" fq-test-tab-name)])))))

        (testing "Show that transaction (autocommit = false + {:transaction? false}) w/out explicit commit will be implicitly rolled back."
          (is (empty? (jdbc/query conn-read [(format "select * from %s where id = 33" fq-test-tab-name)]))))

      (catch Exception e
        (throw e))
        (finally
          ; Ensure connection is closed in order to end any open transactions
          (when-let [jdbc-conn (:connection conn-read)]
           (when-not (.isClosed jdbc-conn) (.close jdbc-conn)))))))


  (testing "Nested transaction behavior"
    (dbconfig-override DB-SPEC redshift)

    (jdbc/with-db-connection [conn (dbconfig {} DB-SPEC)]
      (try

        (.setAutoCommit (:connection conn) false) ; It's the default, per docs, but just to be sure...

        (jdbc-succeeds
          (create-test-table conn)

          ;(jdbc/execute! conn ["BEGIN;"] {:transaction? false})
          (jdbc/execute! conn
            [(format "insert into %s values (40, 'autocommit = false + :transaction? false; implicit JDBC transaction begun');" fq-test-tab-name)]
            {:transaction? false})
          (jdbc/execute! conn
            [(format "BEGIN;
              insert into %s values (41, 'autocommit = false + :transaction? false; SQL transaction (BEGIN, COMMIT) nested in JDBC transaction (implicit)');
              COMMIT;" fq-test-tab-name)]
            {:transaction? false})
          (jdbc/execute! conn
            [(format "BEGIN;
              insert into %s values (42, 'autocommit = false + :transaction? false; SQL transaction (BEGIN, COMMIT) begun');
                BEGIN;
                insert into %s values (43, 'autocommit = false + :transaction? false; SQL transaction (BEGIN, COMMIT) nested in SQL transaction');
                COMMIT;
              ROLLBACK;" fq-test-tab-name fq-test-tab-name)]
            {:transaction? false}))

        (catch Exception e
          (throw e))
        (finally
          ; Ensure connection is closed in order to end any open transactions
          (when-let [jdbc-conn (:connection conn)]
           (when-not (.isClosed jdbc-conn) (.close jdbc-conn))))))
        
  (jdbc/with-db-connection [conn-read (dbconfig {} DB-SPEC)]
    (testing "Show that SQL trans markers (BEGIN, COMMIT) issued in an already open JDBC transaction will commit any modifications made prior to the SQL BEGIN marker (i.e. nested transactions are silently ignored)"
      (is (not (empty? (jdbc/query conn-read [(format "select * from %s where id = 40" fq-test-tab-name)])))))

    (testing "Show that SQL trans markers (BEGIN, COMMIT) issued in an already open JDBC transaction are respected"
      (is (not (empty? (jdbc/query conn-read [(format "select * from %s where id = 41" fq-test-tab-name)])))))

    (testing "Show that SQL trans markers (BEGIN, COMMIT) nested in another SQL transaction are silently ignored"
      (is (not (empty? (jdbc/query conn-read [(format "select * from %s where id = 42" fq-test-tab-name)])))))))

  (testing "Transaction behavior with with-db-transaction"
    (dbconfig-override DB-SPEC redshift)

    (let [fq-test-tab-name-2 (base-tab-name->timestamped-tab-name test-tab-base-name test-tab-schema (joda-date-time->str))]
      (jdbc/with-db-transaction [conn (dbconfig {} DB-SPEC)]
        
        (jdbc-succeeds
          (create-test-table conn)
      
          (jdbc/execute! conn [(format "insert into %s values (50, 'autocommit = false + :transaction? false; implicit JDBC transaction begun');" fq-test-tab-name)])
            
            (jdbc/with-db-connection [conn-read (dbconfig {} DB-SPEC)]
              (testing "Does execute! in with-db-transaction transaction auto-commit w/out :transaction? false"
                (is (empty? (jdbc/query conn-read [(format "select * from %s where id = 50" fq-test-tab-name)])))))

            (try
              (create-test-tab fq-test-tab-name-2)
              (jdbc/with-db-transaction [conn-new (dbconfig {} DB-SPEC)]
                  (jdbc/execute! conn-new [(format "insert into %s values (51, 'autocommit = false + :transaction? false; implicit JDBC transaction begun');" fq-test-tab-name-2)]))

              (jdbc/with-db-connection [conn-read (dbconfig {} DB-SPEC)]
                (testing "Show that nested with-db-transaction operate independently of wrapping with-db-transaction (nested transaction committed)."
                  (is (not (empty? (jdbc/query conn-read [(format "select * from %s where id = 51" fq-test-tab-name-2)])))))
                (testing "Show that nested with-db-transaction operate independently of wrapping with-db-transaction (outer transaction not committed)."
                  (is (empty? (jdbc/query conn-read [(format "select * from %s where id = 50" fq-test-tab-name)])))))

              (catch Exception e
                (throw e))
              (finally
                (drop-test-tab fq-test-tab-name-2))))))

    (jdbc/with-db-connection [conn-read (dbconfig {} DB-SPEC)]
      (testing "Show that nested with-db-transaction commits by default."
        (is (not (empty? (jdbc/query conn-read [(format "select * from %s where id = 50" fq-test-tab-name)])))))))


  (testing "with-db-transaction nested transaction behavior"
    (dbconfig-override DB-SPEC redshift)

    (jdbc/with-db-connection [conn (dbconfig {} DB-SPEC)]
      (try
        (create-test-table conn)
        (finally
          ; Ensure connection is closed in order to end any open transactions
          (when-let [jdbc-conn (:connection conn)]
           (when-not (.isClosed jdbc-conn) (.close jdbc-conn))))))

    (jdbc/with-db-transaction [conn-new (dbconfig {} DB-SPEC)]
      (jdbc-succeeds
      
          (jdbc/execute! conn-new [(format "insert into %s values (60, 'autocommit = false + :transaction? false; implicit JDBC transaction begun');" fq-test-tab-name)])

          (jdbc/with-db-connection [conn-read (dbconfig {} DB-SPEC)]
            (testing "Show that SQL trans markers (BEGIN, COMMIT) issued in an already open with-db-transaction will not commit any modifications made prior to the SQL BEGIN marker"
              (is (empty? (jdbc/query conn-read [(format "select * from %s where id = 60" fq-test-tab-name)])))))

          (jdbc/execute! conn-new
            [(format "insert into %s values (61, 'autocommit = false + :transaction? false; implicit JDBC transaction begun');" fq-test-tab-name)])

          (jdbc/execute! conn-new
            [(format "BEGIN;
              insert into %s values (62, 'autocommit = false + :transaction? false; SQL transaction (BEGIN, COMMIT) nested in JDBC transaction (implicit)');
              COMMIT;" fq-test-tab-name)])

          (jdbc/execute! conn-new
            [(format
              "BEGIN;
               insert into %s values (63, 'autocommit = false + :transaction? false; SQL transaction (BEGIN, COMMIT) begun');
                  BEGIN;
                  insert into %s values (64, 'autocommit = false + :transaction? false; SQL transaction (BEGIN, COMMIT) nested in SQL transaction');
                  COMMIT;
               ROLLBACK;"
               fq-test-tab-name fq-test-tab-name)])))
  
  (jdbc/with-db-connection [conn-read (dbconfig {} DB-SPEC)]
    (testing "Show that SQL trans markers (BEGIN, COMMIT) issued in an already open JDBC transaction are respected"
      (is (not (empty? (jdbc/query conn-read [(format "select * from %s where id = 61" fq-test-tab-name)])))))

    (testing "Show that SQL trans markers (BEGIN, COMMIT) nested in another SQL transaction are silently ignored"
      (is (not (empty? (jdbc/query conn-read [(format "select * from %s where id = 62" fq-test-tab-name)])))))))

